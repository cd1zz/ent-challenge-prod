"""Game Segmentation Module for Battle Royale Videos.

This module detects game boundaries (start/end times) from video frame
classifications generated by CLIP. It identifies distinct matches within
continuous gameplay recordings by tracking visual indicators like parachute
landings, death screens, and victory screens.

The segmentation is based on confidence thresholds and temporal patterns to
minimize false positives from brief UI overlays or spectator transitions.

Typical usage example:

    from game_segmenter import GameSegmenter, segment_video_games

    # From action classification results
    segmenter = GameSegmenter(
        parachute_confidence_threshold=0.85,
        min_game_duration=60.0
    )
    games = segmenter.segment_games(actions_data)

    # Or use convenience function
    analysis = segment_video_games("actions.json", "games.json")
"""

import json
from datetime import datetime
from typing import Dict, List, Optional, Tuple


class GameSegmenter:
    """Segment video into individual games based on CLIP action classifications.

    This class analyzes frame-by-frame action classifications to identify game
    boundaries. It uses confidence thresholds and temporal validation to detect:
    - Game starts: Parachute landing sequences
    - Game ends: Death/spectating, victory screens, defeat screens

    The segmenter tracks game state transitions and applies heuristics to avoid
    false positives from brief UI elements or camera changes.

    Attributes:
        parachute_threshold (float): Minimum confidence for parachute detection.
        death_threshold (float): Minimum confidence for death/end screen detection.
        min_game_duration (float): Minimum valid game duration in seconds.
        max_pregame_duration (float): Maximum pregame lobby duration in seconds.
        GAME_START_INDICATORS (List[str]): Action labels indicating game start.
        GAME_END_INDICATORS (List[str]): Action labels indicating game end.
        MENU_INDICATORS (List[str]): Action labels for menu/lobby screens.
    """

    # Game state indicators
    GAME_START_INDICATORS = [
        "player parachuting and landing",
        "loading screen or match starting",
    ]

    GAME_END_INDICATORS = [
        "player dead or spectating teammates",
        "victory screen showing final placement",
        "defeat screen or player eliminated",
    ]

    MENU_INDICATORS = [
        "main menu or lobby screen",
    ]

    def __init__(
        self,
        parachute_confidence_threshold: float = 0.85,
        death_confidence_threshold: float = 0.60,
        min_game_duration: float = 60.0,
        max_pregame_duration: float = 120.0
    ) -> None:
        """Initialize game segmenter with detection thresholds.

        Args:
            parachute_confidence_threshold: Minimum confidence (0.0-1.0) for
                detecting parachute landing as game start. Higher values reduce
                false positives but may miss starts. Default is 0.85.
            death_confidence_threshold: Minimum confidence (0.0-1.0) for
                detecting death/spectating as game end. Lower than parachute
                threshold because death screens can be brief. Default is 0.60.
            min_game_duration: Minimum game duration in seconds to be considered
                valid. Filters out false positives from lobby navigation.
                Default is 60.0 seconds (1 minute).
            max_pregame_duration: Maximum time in seconds before parachute to
                search for lobby/loading screens. Default is 120.0 seconds.

        Example:
            >>> segmenter = GameSegmenter(
            ...     parachute_confidence_threshold=0.90,  # More strict
            ...     min_game_duration=120.0  # Only games > 2 minutes
            ... )
        """
        self.parachute_threshold = parachute_confidence_threshold
        self.death_threshold = death_confidence_threshold
        self.min_game_duration = min_game_duration
        self.max_pregame_duration = max_pregame_duration

    def segment_games(self, actions_data: List[Dict]) -> List[Dict]:
        """Segment video into individual games based on action classifications.

        Analyzes the sequence of frame classifications to identify game boundaries.
        The algorithm:
        1. Detects game starts via parachute landing sequences
        2. Tracks active game state until end conditions
        3. Validates game end by confirming sustained end screen detection
        4. Filters out invalid games below minimum duration

        Args:
            actions_data: List of action classification results from CLIP.
                Each entry must contain:
                - 'timestamp' (float): Frame timestamp in seconds
                - 'primary_action' (str): Most likely action label
                - 'all_predictions' (dict): Full probability distribution

                Example entry:
                {
                    'timestamp': 45.2,
                    'primary_action': 'player parachuting and landing',
                    'all_predictions': {
                        'player parachuting and landing': 0.92,
                        'player running between zones': 0.05,
                        ...
                    }
                }

        Returns:
            List of game segment dictionaries, one per detected game.
            Each contains:
            - 'game_number' (int): Sequential game index (1-based)
            - 'start_time' (float): Game start timestamp in seconds
            - 'end_time' (float): Game end timestamp in seconds
            - 'duration' (float): Game length in seconds
            - 'outcome' (str): 'death', 'victory', 'defeat', or 'incomplete'
            - 'parachute_confidence' (float): Confidence of start detection
            - 'end_confidence' (float): Confidence of end detection
            - 'frame_count' (int): Estimated number of frames in game

        Example:
            >>> with open('actions.json') as f:
            ...     actions = json.load(f)['results']
            >>> segmenter = GameSegmenter()
            >>> games = segmenter.segment_games(actions)
            >>> print(f"Found {len(games)} games")
            >>> for game in games:
            ...     print(f"Game {game['game_number']}: "
            ...           f"{game['duration']:.0f}s - {game['outcome']}")
        """
        games = []
        current_game = None
        parachute_sequence_active = False
        parachute_sequence_start = None

        for i, frame_data in enumerate(actions_data):
            timestamp = frame_data['timestamp']
            action = frame_data['primary_action']
            predictions = frame_data['all_predictions']

            # Get confidence for relevant actions
            parachute_conf = predictions.get("player parachuting and landing", 0.0)
            death_conf = predictions.get("player dead or spectating teammates", 0.0)
            victory_conf = predictions.get("victory screen showing final placement", 0.0)
            defeat_conf = predictions.get("defeat screen or player eliminated", 0.0)

            # === DETECT GAME START ===
            if parachute_conf >= self.parachute_threshold:
                if not parachute_sequence_active:
                    parachute_sequence_active = True
                    parachute_sequence_start = timestamp

                    # If no game is active, start a new game
                    if current_game is None:
                        current_game = {
                            'game_number': len(games) + 1,
                            'start_time': timestamp,
                            'parachute_confidence': parachute_conf,
                            'parachute_start': timestamp
                        }

            # Track when parachute sequence ends
            elif parachute_sequence_active and parachute_conf < 0.4:
                parachute_sequence_active = False

            # === DETECT GAME END ===
            if current_game is not None:
                # Check for death/spectating
                if death_conf >= self.death_threshold:
                    # Look ahead to confirm (avoid brief spectating during revive)
                    if self._confirm_game_end(actions_data, i, "death"):
                        current_game['end_time'] = timestamp
                        current_game['outcome'] = 'death'
                        current_game['end_confidence'] = death_conf
                        self._finalize_game(current_game, games)
                        current_game = None

                # Check for victory
                elif victory_conf >= 0.5:
                    current_game['end_time'] = timestamp
                    current_game['outcome'] = 'victory'
                    current_game['end_confidence'] = victory_conf
                    self._finalize_game(current_game, games)
                    current_game = None

                # Check for defeat screen
                elif defeat_conf >= 0.6:
                    current_game['end_time'] = timestamp
                    current_game['outcome'] = 'defeat'
                    current_game['end_confidence'] = defeat_conf
                    self._finalize_game(current_game, games)
                    current_game = None

        # Handle game that didn't end properly (video ended during gameplay)
        if current_game is not None:
            current_game['end_time'] = actions_data[-1]['timestamp']
            current_game['outcome'] = 'incomplete'
            current_game['end_confidence'] = 0.0
            self._finalize_game(current_game, games)

        return games

    def _confirm_game_end(
        self,
        actions_data: List[Dict],
        current_idx: int,
        end_type: str,
        lookahead_frames: int = 10
    ) -> bool:
        """Confirm game end by validating sustained end screen detection.

        Looks ahead at subsequent frames to verify that the end condition
        persists, avoiding false positives from brief spectator mode during
        revive mechanics or temporary UI overlays.

        Args:
            actions_data: Full list of action classification data.
            current_idx: Index of current frame in actions_data where end
                condition was initially detected.
            end_type: Type of game end to validate. Currently only 'death'
                requires confirmation; other types are instantly confirmed.
            lookahead_frames: Number of subsequent frames to check for
                sustained end condition. Default is 10 frames.

        Returns:
            True if game end is confirmed by sustained detection, False if
            the end condition was transient and game is still active.

        Note:
            For 'death' end type, requires that at least 60% of lookahead
            frames also show death/spectating to confirm game end. This
            threshold balances between detecting legitimate game ends and
            avoiding false positives during revive sequences.
        """
        if end_type == "death":
            death_count = 0
            for i in range(current_idx, min(current_idx + lookahead_frames, len(actions_data))):
                frame = actions_data[i]
                death_conf = frame['all_predictions'].get("player dead or spectating teammates", 0.0)
                if death_conf >= self.death_threshold:
                    death_count += 1

            # Confirm if death is sustained for multiple frames
            return death_count >= lookahead_frames * 0.6

        return True  # Other end types confirmed immediately

    def _finalize_game(self, game: Dict, games_list: List[Dict]) -> None:
        """Finalize game segment and add to list if valid.

        Calculates derived fields (duration, frame count) and validates that
        the game meets minimum duration requirements before adding to the
        output list. Invalid games are silently discarded.

        Args:
            game: Game data dictionary containing at minimum 'start_time' and
                'end_time' keys. Will be modified in-place to add 'duration'
                and 'frame_count' fields.
            games_list: List to append finalized game to if valid. Modified
                in-place.

        Note:
            Games shorter than min_game_duration are not added to games_list.
            This filters out false positives from menu navigation or loading
            screen transitions.
        """
        # Calculate duration
        game['duration'] = game['end_time'] - game['start_time']

        # Count frames (if available)
        game['frame_count'] = int(game['duration'] / 2.0)  # Assuming 2s intervals

        # Only add if duration is reasonable
        if game['duration'] >= self.min_game_duration:
            games_list.append(game)

    def analyze_games(self, games: List[Dict]) -> Dict:
        """Compute summary statistics for detected games.

        Args:
            games: List of game segment dictionaries from segment_games().

        Returns:
            Dictionary containing aggregate statistics:
            - 'total_games' (int): Number of detected games
            - 'total_duration' (float): Sum of all game durations in seconds
            - 'avg_game_duration' (float): Mean game duration in seconds
            - 'min_game_duration' (float): Shortest game duration in seconds
            - 'max_game_duration' (float): Longest game duration in seconds
            - 'outcomes' (dict): Count of each outcome type (death, victory, etc.)
            - 'games' (list): Original games list (passed through)

            Returns zeros and empty dict for outcomes if games list is empty.

        Example:
            >>> games = segmenter.segment_games(actions_data)
            >>> stats = segmenter.analyze_games(games)
            >>> print(f"Average game: {stats['avg_game_duration']/60:.1f} minutes")
            >>> print(f"Win rate: {stats['outcomes'].get('victory', 0)}/{stats['total_games']}")
        """
        if not games:
            return {
                'total_games': 0,
                'total_duration': 0,
                'avg_game_duration': 0,
                'outcomes': {}
            }

        total_duration = sum(g['duration'] for g in games)
        outcomes = {}
        for game in games:
            outcome = game['outcome']
            outcomes[outcome] = outcomes.get(outcome, 0) + 1

        return {
            'total_games': len(games),
            'total_duration': total_duration,
            'avg_game_duration': total_duration / len(games),
            'min_game_duration': min(g['duration'] for g in games),
            'max_game_duration': max(g['duration'] for g in games),
            'outcomes': outcomes,
            'games': games
        }

    def save_segmentation(self, games: List[Dict], output_file: str) -> None:
        """Save game segmentation results to JSON file.

        Combines game segments with analysis statistics and saves to a formatted
        JSON file with timestamp metadata.

        Args:
            games: List of game segment dictionaries from segment_games().
            output_file: Path where JSON results will be written. Parent
                directories must exist. File will be overwritten if it exists.

        Raises:
            IOError: If file cannot be written.

        Example:
            >>> games = segmenter.segment_games(actions_data)
            >>> segmenter.save_segmentation(games, "output/games.json")
            ✓ Game segmentation saved to: output/games.json
        """
        analysis = self.analyze_games(games)
        analysis['timestamp'] = datetime.now().isoformat()

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(analysis, f, indent=2)

        print(f"✓ Game segmentation saved to: {output_file}")


def segment_video_games(
    actions_file: str,
    output_file: Optional[str] = None
) -> Dict:
    """Convenience function to segment games from action classification file.

    Loads action classifications from a JSON file, performs game segmentation,
    and optionally saves results. Prints a formatted summary of detected games.

    Args:
        actions_file: Path to JSON file containing CLIP action classifications.
            Must contain either a 'results' key with action list, or be a
            direct list of action dictionaries.
        output_file: Optional path to save segmentation results as JSON.
            If None, results are only returned and printed. If provided,
            results will be saved using save_segmentation().

    Returns:
        Game analysis dictionary from GameSegmenter.analyze_games() containing:
        - Summary statistics (total_games, durations, etc.)
        - Full list of detected games with timestamps and metadata

    Raises:
        FileNotFoundError: If actions_file does not exist.
        json.JSONDecodeError: If actions_file is not valid JSON.

    Example:
        >>> analysis = segment_video_games(
        ...     "output/actions.json",
        ...     "output/games.json"
        ... )
        Game Segmentation Results:
        ============================================================
        Total games detected: 3
        Total gameplay time: 1847.2s
        Average game duration: 615.7s

        Outcomes:
          death: 2
          victory: 1

        Games:
          Game 1: 11:23 (45.0s - 728.0s) - death
          Game 2: 09:15 (892.0s - 1447.0s) - victory
          Game 3: 06:40 (1520.0s - 1920.0s) - death
        ✓ Game segmentation saved to: output/games.json
    """
    # Load actions
    with open(actions_file, 'r') as f:
        actions_data_full = json.load(f)
        actions_data = actions_data_full.get('results', actions_data_full)

    # Segment games
    segmenter = GameSegmenter()
    games = segmenter.segment_games(actions_data)
    analysis = segmenter.analyze_games(games)

    # Print summary
    print("\nGame Segmentation Results:")
    print("=" * 60)
    print(f"Total games detected: {analysis['total_games']}")
    print(f"Total gameplay time: {analysis['total_duration']:.1f}s")
    print(f"Average game duration: {analysis['avg_game_duration']:.1f}s")
    print(f"\nOutcomes:")
    for outcome, count in analysis['outcomes'].items():
        print(f"  {outcome}: {count}")

    print(f"\nGames:")
    for game in games:
        mins = int(game['duration'] // 60)
        secs = int(game['duration'] % 60)
        print(f"  Game {game['game_number']}: {mins:02d}:{secs:02d} "
              f"({game['start_time']:.1f}s - {game['end_time']:.1f}s) "
              f"- {game['outcome']}")

    # Save if requested
    if output_file:
        segmenter.save_segmentation(games, output_file)

    return analysis
